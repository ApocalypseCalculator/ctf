# Stack Cache

### Problem

A simple buffer overflow where you have to chain two function calls to leak a flag value stored on the stack.

### Solution

Given the source code, we can see two functions of interest, `win` and `UnderConstruction`. The `vuln` function calls `gets` which is vulnerable to buffer overflow. 

Evidently, we have to call the `win` function. To do this, we will overflow the buffer to overwrite the stored return pointer with the address of `win` (which we can determine using GDB as `0x8049da0`).

This calls the function, but there is a problem. The function does not actually print the flag, but only load it into another buffer. Here is where we will use the `UnderConstruction` function. 

This function prints out a series of pointer values, but the pointers they are printing are uninitialized. In C, this is undefined behavior. However, by experimenting in GDB, we find that it will leak stack values as hexadecimal. Since the flag was just loaded onto the stack, it should be recent enough so that it will print out the flag's characters.

To call this function, we will overwrite the address after the stored return pointer with the address of `UnderConstruction`. This means that when `win` returns, it will jump to `UnderConstruction`.

Payload:
```python
from pwn import *

r = remote('saturn.picoctf.net', 56826)

payload = b'A' * 14 + p32(0x8049da0) + p32(0x8049e20)
r.sendline(payload)
r.interactive()
```

Output:
```
User information : 0x80c9a04 0x804007d 0x39623938 0x30356438 0x5f597230 0x6d334d5f
Names of user: 0x50755f4e 0x34656c43 0x7b465443
Age of user: 0x6f636970
```

Decoding the hex values as ASCII and accounting for endianness, we can find the flag, `picoCTF{Cle4N_uP_M3m0rY_8d5089b9}`.
